### -----------------------------
## advanced R & recent advances in R
## simon munzert
### -----------------------------


## peparations -------------------

source("00-course-setup.r")
wd <- getwd()


## debugging ----------------------

# when you write code, things will inevitably go wrong at some point
# you can professionalize the way of how to
  # fix unanticipated problems (debugging)
  # let functions communicate problems and take actions based on those communications (condition handling)
  # learn how to avoid common problems before they occur (defensive programming)

# communication of problems via "conditions": errors, warnings, and messages

# fatal errors are raised by stop() and force all execution to terminate
# warnings are generated by warning() and display potential problems
# messages are generated by message() and can provide informative output on the way

# other ways of communicating work via print() and cat(), but that's probably a bad idea because they aren't conditions and cannot be used with useful condition handling tools


## debugging workflow -----------

# 1. realize that you have a bug
# 2. make bug repeatable: start with big block of code and narrow it down to isolate it
# 3. figure out where it is
# 4. fix it and test it

## debugging tools --------------

# there are tools provided by R and other by the RStudio IDE
# for the latter, see 
browseURL("http://www.rstudio.com/ide/docs/debugging/overview")

# determining the sequence of calls
f <- function(a) g(a) 
g <- function(b) h(b) 
h <- function(c) i(c) 
i <- function(d) "a" + d 
f(10)

traceback() # this shows you where the error occurred, but not why

# browsing on error
# ???


## condition handling --------------

# sometimes, errors are expected, and you want to handle them automatically, e.g.
  # model fails to converge
  # download of files fails
  # stack processing of lists

# most useful functions: try() and tryCatch()

f1 <- function(x) { 
  log(x) 
  10 
  } 
f1("x")

# ignore error
f1 <- function(x) { 
  try(log(x))
  10 
} 
f1("x")

# suppress error message
f1 <- function(x) { 
  try(log(x), silent = TRUE)
  10 
} 
f1("x")

# pass block of code to try()
try({ 
  a <- 1 
  b <- "x" 
  a + b 
})

# capture the output of try()
success <- try(1 + 2) 
failure <- try("a" + "b") 
class(success)
class(failure) 

# use try() when applying a function to multiple elements in a list
elements <- list(1:10, c(-1, 10), c(T, F), letters) 
results <- lapply(elements, log)

results <- lapply(elements, function(x) try(log(x)))

# test for "try-error" class
is.error <- function(x) inherits(x, "try-error") 
succeeded <- !sapply(results, is.error)

str(results[succeeded])
str(elements[!succeeded])

# use try() together with a default value if expression fails
default <- NULL 
try(default <- read.csv("possibly-bad-input.csv"), silent = TRUE)

# even easier with failwith()
safe_fun <- plyr::failwith(default = NULL, f = log, quiet = FALSE)
safe_fun(3)
safe_fun("3")


# handle conditions with tryCatch()

# react to conditions, such as errors, warnings, messages, or interruptions, with certain actions
# "handlers" (functions that are called with the condition as an input) are mapped to conditions
# handler functions can do anything but typically will return a value or create a more informative error message

show_condition <- function(code) { 
  tryCatch(code, 
           error = function(c) "error", 
           warning = function(c) "warning", 
           message = function(c) "message" )
  }

show_condition(stop("!"))
show_condition(warning("?!"))
show_condition(message("?"))
# if no condition is captured, tryCatch returns the value of the input
show_condition(10+5)

# make more informative error messages
read.csv_new <- function(file, ...) { 
  tryCatch(read.csv(file, ...), error = function(c) {
    c$message <- paste0(c$message, " (in ", file, ")") 
    stop(c) 
  })
}

read.csv("code/dummy.csv")
read.csv_new("code/dummy.csv")


## defensive programming -----------------

# "making code fail in a well-defined manner"
# "fail fast": as soon as something wrong is discovered, signal an error
# three rules to implement the "fail fast" principle:
  # be strict about what you accept (e.g., only scalars)
  # avoid functions that use non-standard evaluation, such as subset(), transform(), or with()
  # avoid functions that return different types of output depending on their input, e.g. [ and sapply

