### -----------------------------
## advanced R & recent advances in R
## simon munzert
### -----------------------------


## peparations -------------------

source("00-course-setup.r")
wd <- getwd()



## debugging ----------------------

# when you write code, things will inevitably go wrong at some point
# you can professionalize the way of how to
  # fix unanticipated problems (debugging)
  # let functions communicate problems and take actions based on those communications (condition handling)
  # learn how to avoid common problems before they occur (defensive programming)

# communication of problems via "conditions": errors, warnings, and messages

# fatal errors are raised by stop() and force all execution to terminate
# warnings are generated by warning() and display potential problems
# messages are generated by message() and can provide informative output on the way

# other ways of communicating work via print() and cat(), but that's probably a bad idea because they aren't conditions and cannot be used with useful condition handling tools


## debugging workflow -----------

# 1. realize that you have a bug
# 2. make bug repeatable: start with big block of code and narrow it down to isolate it
# 3. figure out where it is
# 4. fix it and test it


## debugging tools --------------
# inspired by [https://goo.gl/ofIibl]

# Calculates the geodesic distance between two points specified by radian latitude/longitude using the Haversine formula (hf); taken from [https://goo.gl/GezNGB]
geod_dist <- function(lat1, lon1, lat2, lon2, earth.radius = 6371) {
  # from degrees to radians
  deg2rad <- function(deg) return(deg*pi/180)
  lon1 <- deg2rad(lon1)
  lat1 <- deg2rad(lat1)
  lon2 <- deg2rad(long2)
  lat2 <- deg2rad(lat2)
  # calculation
  delta.long <- (lon2 - lon1)
  delta.lat <- (lat2 - lat1)
  a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sing(delta.long/2)^2
  c <- 2 * asin(min(1,sqrt(a)))
  d = earth_radius * c
  return(d)
}

# distance between Mannheim and Berlin
geod_dist(lat1 = 49.5, lon1 = 8.4, lat2 = 52.5, lon2 = 13.4)


## solution 1: trial and error
# if you see the error right away, fix it


## solution 2: make your function global
# turn the arguments into global objects
# step through the code

lat1 = 49.5; lon1 = 8.4; lat2 = 52.5; lon2 = 13.4

deg2rad <- function(deg) return(deg*pi/180)
lon1 <- deg2rad(lon1)
lat1 <- deg2rad(lat1)
lon2 <- deg2rad(long2)
lat2 <- deg2rad(lat2)
delta.long <- (lon2 - lon1)
delta.lat <- (lat2 - lat1)
a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sing(delta.long/2)^2
c <- 2 * asin(min(1,sqrt(a)))
d = earth_radius * c
return(d)

# problem with this solution: creates global objects that match arguments names, can become confusing and cause problems that become obvious when the function is called in a different environment


## solution 3: use traceback()
# this shows you where the error occurred, but not why
geod_dist(lat1 = 49.5, lon1 = 8.4, lat2 = 52.5, lon2 = 13.4)
traceback()


## solution 3: use browser()
geod_dist <- function(lat1, lon1, lat2, lon2, earth.radius = 6371) {
  # from degrees to radians
  browser()
  deg2rad <- function(deg) return(deg*pi/180)
  lon1 <- deg2rad(lon1)
  lat1 <- deg2rad(lat1)
  lon2 <- deg2rad(lon2)
  lat2 <- deg2rad(lat2)
  # calculation
  delta.long <- (lon2 - lon1)
  delta.lat <- (lat2 - lat1)
  a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sing(delta.long/2)^2
  c <- 2 * asin(min(1,sqrt(a)))
  d = earth_radius * c
  return(d)
}
geod_dist(lat1 = 49.5, lon1 = 8.4, lat2 = 52.5, lon2 = 13.4)
# you can now work through the function line by line by hitting enter in the console or send additional lines of code



## condition handling --------------

# sometimes, errors are expected, and you want to handle them automatically, e.g.
  # model fails to converge
  # download of files fails
  # stack processing of lists

# most useful functions: try() and tryCatch()

f1 <- function(x) { 
  log(x) 
  10 
  } 
f1("x")

# ignore error
f1 <- function(x) { 
  try(log(x))
  10 
} 
f1("x")

# suppress error message
f1 <- function(x) { 
  try(log(x), silent = TRUE)
  10 
} 
f1("x")

# pass block of code to try()
try({ 
  a <- 1 
  b <- "x" 
  a + b 
})

# capture the output of try()
success <- try(1 + 2) 
failure <- try("a" + "b") 
class(success)
class(failure) 

# use try() when applying a function to multiple elements in a list
elements <- list(1:10, c(-1, 10), c(T, F), letters) 
results <- lapply(elements, log)

results <- lapply(elements, function(x) try(log(x)))

# test for "try-error" class
is.error <- function(x) inherits(x, "try-error") 
succeeded <- !sapply(results, is.error)

str(results[succeeded])
str(elements[!succeeded])

# use try() together with a default value if expression fails
default <- NULL 
try(default <- read.csv("possibly-bad-input.csv"), silent = TRUE)

# even easier with failwith()
safe_fun <- plyr::failwith(default = NULL, f = log, quiet = FALSE)
safe_fun(3)
safe_fun("3")


# handle conditions with tryCatch()

# react to conditions, such as errors, warnings, messages, or interruptions, with certain actions
# "handlers" (functions that are called with the condition as an input) are mapped to conditions
# handler functions can do anything but typically will return a value or create a more informative error message

show_condition <- function(code) { 
  tryCatch(code, 
           error = function(c) "error", 
           warning = function(c) "warning", 
           message = function(c) "message" )
  }

show_condition(stop("!"))
show_condition(warning("?!"))
show_condition(message("?"))
# if no condition is captured, tryCatch returns the value of the input
show_condition(10+5)

# make more informative error messages
read.csv_new <- function(file, ...) { 
  tryCatch(read.csv(file, ...), error = function(c) {
    c$message <- paste0(c$message, " (in ", file, ")") 
    stop(c) 
  })
}

read.csv("code/dummy.csv")
read.csv_new("code/dummy.csv")


## defensive programming -----------------

# "making code fail in a well-defined manner"
# "fail fast": as soon as something wrong is discovered, signal an error
# three rules to implement the "fail fast" principle:
  # be strict about what you accept (e.g., only scalars)
  # avoid functions that use non-standard evaluation, such as subset(), transform(), or with()
  # avoid functions that return different types of output depending on their input, e.g. [ and sapply

